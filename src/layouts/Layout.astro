// src/pages/api/og/[slug].png.ts
import type { APIRoute } from 'astro';
import { getEntryBySlug } from 'astro:content';
import { satori } from 'astro:satori';
import { html } from 'satori-html';
import sharp from 'sharp';
import BlogOGImage from '../../../components/BlogOGImage.astro';

// ===== INICIO DE LA CORRECCIÓN: Usar 'fs' y 'url' para leer archivos =====
import { readFile } from 'fs/promises';
import { fileURLToPath } from 'url';

// Función CORREGIDA para leer fuentes
async function readFont(fontPath: string): Promise<ArrayBuffer> {
  const url = new URL(fontPath, import.meta.url);
  return await readFile(fileURLToPath(url));
}
// ===== FIN DE LA CORRECCIÓN =====

export const GET: APIRoute = async ({ params }) => {
  const slug = params.slug;
  if (!slug) {
    return new Response('Slug no encontrado', { status: 404 });
  }

  const post = await getEntryBySlug('blog', slug);
  if (!post) {
    return new Response(`Post no encontrado: ${slug}`, { status: 404 });
  }

  // Cargar fuentes usando la función CORREGIDA
  const [playfairData, interData] = await Promise.all([
    readFont('../../../public/fonts/PlayfairDisplay-Bold.ttf'),
    readFont('../../../public/fonts/Inter-Regular.ttf')
  ]);

  // Renderizar componente a HTML
  const markup = html((await BlogOGImage({ title: post.data.title })).toString());

  // Generar SVG
  const svg = await satori(markup, {
    width: 1200,
    height: 630,
    fonts: [
      { name: 'Playfair Display', data: playfairData, weight: 700, style: 'normal' },
      { name: 'Inter', data: interData, weight: 400, style: 'normal' },
    ],
  });

  // Convertir SVG a PNG
  const png = await sharp(Buffer.from(svg)).png().toBuffer();

  // Devolver la imagen PNG
  return new Response(png, {
    status: 200,
    headers: {
      'Content-Type': 'image/png',
      'Cache-Control': 'public, max-age=604800, immutable', // Cache por 1 semana
    },
  });
};


